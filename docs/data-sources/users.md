---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "ad_users Data Source - ad"
subcategory: ""
description: |-
  Retrieves a list of Active Directory users based on search criteria. Supports filtering by name patterns, organizational information, account status, and email properties.
---

# ad_users (Data Source)

Retrieves a list of Active Directory users based on search criteria. Supports filtering by name patterns, organizational information, account status, and email properties.

## Example Usage

```terraform
# AD Users Data Source Example

terraform {
  required_providers {
    ad = {
      source = "isometry/ad"
    }
  }
}

provider "ad" {
  domain   = "example.com"
  username = "admin@example.com"
  password = "secure_password"
}

# Find all users in a specific OU
data "ad_users" "it_users" {
  container = "ou=IT Department,ou=Users,dc=example,dc=com"
  scope     = "subtree"
}

# Find users by department
data "ad_users" "hr_department" {
  container = "ou=Users,dc=example,dc=com"
  scope     = "subtree"

  filter = {
    department = "Human Resources"
  }
}

# Find enabled users only
data "ad_users" "active_users" {
  container = "ou=Users,dc=example,dc=com"
  scope     = "subtree"

  filter = {
    enabled = true
  }
}

# Find disabled users for cleanup
data "ad_users" "disabled_users" {
  container = "ou=Users,dc=example,dc=com"
  scope     = "subtree"

  filter = {
    enabled = false
  }
}

# Find users by title containing "Manager"
data "ad_users" "managers" {
  container = "ou=Users,dc=example,dc=com"
  scope     = "subtree"

  filter = {
    title_contains = "Manager"
    enabled        = true
  }
}

# Find users by company
data "ad_users" "company_users" {
  container = "dc=example,dc=com"
  scope     = "subtree"

  filter = {
    company = "Example Corp"
  }
}

# Find users with specific attributes
data "ad_users" "users_with_email" {
  container = "ou=Users,dc=example,dc=com"
  scope     = "subtree"

  filter = {
    has_email = true
    enabled   = true
  }
}

# Complex search combining multiple filters
data "ad_users" "it_managers" {
  container = "ou=IT Department,ou=Users,dc=example,dc=com"
  scope     = "subtree"

  filter = {
    department     = "Information Technology"
    title_contains = "Manager"
    enabled        = true
    has_email      = true
  }
}

# Search across multiple OUs
variable "search_ous" {
  type = list(string)
  default = [
    "ou=IT,ou=Users,dc=example,dc=com",
    "ou=HR,ou=Users,dc=example,dc=com",
    "ou=Finance,ou=Users,dc=example,dc=com"
  ]
}

data "ad_users" "department_users" {
  for_each = toset(var.search_ous)

  container = each.value
  scope     = "onelevel"

  filter = {
    enabled = true
  }
}

# Create department-specific groups based on user search results
resource "ad_group" "department_groups" {
  for_each = data.ad_users.department_users

  name             = "${basename(each.key)} Users"
  sam_account_name = "${replace(basename(each.key), " ", "")}Users"
  container        = "ou=Department Groups,dc=example,dc=com"
  scope            = "Global"
  category         = "Security"
  description      = "All users in ${basename(each.key)}"
}

# Add users to their respective department groups
resource "ad_group_membership" "department_memberships" {
  for_each = data.ad_users.department_users

  group_id = ad_group.department_groups[each.key].id
  members  = each.value.users[*].dn
}

# Create manager groups automatically
resource "ad_group" "managers_group" {
  name             = "All Managers"
  sam_account_name = "AllManagers"
  container        = "ou=Management Groups,dc=example,dc=com"
  scope            = "Global"
  category         = "Security"
  description      = "All users with manager titles"
}

resource "ad_group_membership" "managers_membership" {
  group_id = ad_group.managers_group.id
  members  = data.ad_users.managers.users[*].dn
}

# Generate comprehensive user reports
locals {
  all_users = flatten([
    for ou, users_data in data.ad_users.department_users : users_data.users
  ])

  user_analysis = {
    total_users = length(local.all_users)

    by_department = {
      for dept, users in {
        for user in local.all_users :
        user.department => user.department
        if user.department != null
        } : dept => length([
          for user in local.all_users :
          user if user.department == dept
      ])
    }

    by_title = {
      for title, users in {
        for user in local.all_users :
        user.title => user.title
        if user.title != null
        } : title => length([
          for user in local.all_users :
          user if user.title == title
      ])
    }

    enabled_count  = length([for u in local.all_users : u if u.enabled == true])
    disabled_count = length([for u in local.all_users : u if u.enabled == false])
    with_email     = length([for u in local.all_users : u if u.email != null && u.email != ""])
  }
}

# Output search results and analysis
output "search_results" {
  value = {
    it_users = {
      count = data.ad_users.it_users.user_count
      users = data.ad_users.it_users.users[*].sam_account_name
    }
    hr_users = {
      count = length(data.ad_users.hr_department.users)
      users = data.ad_users.hr_department.users[*].sam_account_name
    }
    managers = {
      count = length(data.ad_users.managers.users)
      users = data.ad_users.managers.users[*].display_name
    }
    disabled_users = {
      count = length(data.ad_users.disabled_users.users)
      users = data.ad_users.disabled_users.users[*].sam_account_name
    }
  }
}

output "user_statistics" {
  value = local.user_analysis
}

# Sample users for reference
output "sample_users" {
  value = {
    for idx, user in slice(data.ad_users.active_users.users, 0, min(5, length(data.ad_users.active_users.users))) :
    idx => {
      name       = user.display_name
      sam        = user.sam_account_name
      upn        = user.upn
      department = user.department
      title      = user.title
      email      = user.email
    }
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `container` (String) The DN of the container to search within. If not specified, searches from the base DN. Example: `OU=Users,DC=example,DC=com`
- `filter` (Block, Optional) Filter criteria for searching users. All specified criteria must match (AND logic). (see [below for nested schema](#nestedblock--filter))
- `scope` (String) The search scope to use. Valid values: `base`, `onelevel`, `subtree`. Defaults to `subtree`.

### Read-Only

- `id` (String) A computed identifier for this data source instance.
- `user_count` (Number) The total number of users found matching the search criteria.
- `users` (Attributes List) List of users matching the search criteria. (see [below for nested schema](#nestedatt--users))

<a id="nestedblock--filter"></a>
### Nested Schema for `filter`

Optional:

- `company` (String) Filter by company name (exact match, case-insensitive).
- `department` (String) Filter by department. Case-insensitive partial match.
- `email_domain` (String) Filter by email domain (e.g., `example.com`). Only returns users whose email addresses end with the specified domain.
- `enabled` (Boolean) Filter by account status. `true` returns only enabled accounts, `false` returns only disabled accounts. If not specified, returns all accounts.
- `has_email` (Boolean) Filter by email presence. `true` returns only users with email addresses, `false` returns only users without email addresses. If not specified, returns all users.
- `manager` (String) Filter by manager. Accepts Distinguished Name, GUID, UPN, or SAM account name.
- `member_of` (String) Filter by group membership. Only returns users who are members of the specified group (Distinguished Name). Includes nested group membership. Prefix with `!` to negate (users NOT in group). Examples: `CN=Domain Users,CN=Users,DC=example,DC=com` or `!CN=Disabled Users,CN=Users,DC=example,DC=com`
- `name_contains` (String) Users whose common name contains this string. Case-insensitive.
- `name_prefix` (String) Users whose common name starts with this string. Case-insensitive.
- `name_suffix` (String) Users whose common name ends with this string. Case-insensitive.
- `office` (String) Filter by office location (exact match, case-insensitive).
- `title` (String) Filter by job title. Case-insensitive partial match.


<a id="nestedatt--users"></a>
### Nested Schema for `users`

Read-Only:

- `account_enabled` (Boolean) Whether the user account is enabled.
- `company` (String) The company name of the user.
- `department` (String) The department of the user.
- `display_name` (String) The display name of the user.
- `dn` (String) The full Distinguished Name of the user.
- `email_address` (String) The primary email address of the user.
- `given_name` (String) The first name (given name) of the user.
- `id` (String) The objectGUID of the user.
- `last_logon` (String) When the user last logged on (RFC3339 format).
- `manager` (String) The Distinguished Name of the user's manager.
- `name` (String) The common name (cn) of the user.
- `office` (String) The physical office location of the user.
- `sam_account_name` (String) The SAM account name (pre-Windows 2000 name) of the user.
- `surname` (String) The last name (surname) of the user.
- `title` (String) The job title of the user.
- `upn` (String) The User Principal Name (UPN) of the user.
- `when_created` (String) When the user was created (RFC3339 format).
